%!TEX root = ../../main.tex

\chapter{Implementierung und Verbesserung der Webseite}
\label{chapter:6}

In den vorherigen Kapiteln wurde zunächst die bisherige Webseite analysiert, um ihre Stärken und Schwächen zu identifizieren.
Anschließend wurde eine Nutzerumfrage durchgeführt, um die Zufriedenheit der NutzerInnen mit der Webseite zu ermitteln.
Darauf aufbauend wurden aus den Ergebnissen der Nutzerumfrage Personas erstellt und Anforderungen abgeleitet.
Diese Anforderungen wurden im \hyperref[chapter:5]{Kapitel 5} spezifiziert und in die Kategorien Muss-, Soll- und Kann-Anforderungen eingeteilt.

Diese Erkenntnisse sollen nun genutzt werden, um eine verbesserte Version der Webseite zu entwickeln.
Bevor dies geschehen kann, muss jedoch die bisherige Codebasis auf ein neues Frontend-Framework migriert werden, da die Zufriedenheit mit dem vorherigen Framework nicht sehr hoch war.
Nach der Migration werden trotzdem die Ergebnisse der Nutzerumfrage genutzt, um die Webseite zu optimieren.
Dabei wird auf die Ergebnisse der Umfrage eingegangen, und die Webseite wird entsprechend angepasst, um die Nutzererfahrung zu verbessern.
Außerdem werden neue Features und Funktionen hinzugefügt, die die Nutzererfahrung bereichern und die NutzerInnen dazu anregen sollen, die Webseite vermehrt zu nutzen.

Bei jedem relevanten Kapitel werden die entsprechenden Anforderungen, welche dadurch Erfüllt werden, referenziert.
Dadurch, dass manche Anforderungen keine explizite Umsetzung erfordern, da diese in jedem Implemtierungsschritt beachtet werden sollten, werden diese durch das Projekt hinweg konstant betrachtet.
Folgende Anforderungen werden konstant beachtet und angewendet:

\begin{enumerate}

    \item \textbf{[R10] Integration von Grafiken}
    \item \textbf{[R12] Modernisierung des Designs}
    \item \textbf{[R15] Benutzerfreundlichkeit}
    \item \textbf{[R16] Modernes Design}
    \item \textbf{[R17] Zuverlässigkeit}
    \item \textbf{[R18] Wartbarkeit und Erweiterbarkeit}
    \item \textbf{[R19] Code Qualität und Styleguide Einhaltung}

\end{enumerate}

\section{Frameworkwechsel und Verbesserungen}

\subsection{Motivation für den Frameworkwechsel}

Die Webseite wurde bisher unter Verwendung des Frontend-Frameworks \textbf{React.js} entwickelt, das aufgrund seiner Beliebtheit bei vielen Entwicklern weit verbreitet ist.
Dennoch wurde die Entscheidung getroffen, das Framework zu wechseln, bedingt durch verschiedene Herausforderungen und auch aufgrund von Kompetenzüberlegungen der Entwickler.
Durch den Übergang zu einem anderen Framework soll die Webentwicklung vereinfacht und die Nutzererfahrung verbessert werden.
Insbesondere sollen bekannte Probleme wie fehlerhaftes State Management vermieden werden.

Wie bereits im \hyperref[chapter:3-frontend-frameworks]{Grundlagenkapitel} erläutert, wird als neue Framework \textbf{Vue} eingeführt, dass ebenfalls weit verbreitet ist und von vielen Entwicklern genutzt wird.

\subsection{Umsetzung des Frameworkwechsels}

Die Umsetzung ist dabei zunächst nicht zu kompliziert, da das gesamte Projekt in verschiedene Abschnitte unterteilt war, wie zum Beispiel das Frontend der Webseite, das Backend und die Datenbank.
Somit musste lediglich der Ordner, der das Frontend beinhaltet, ausgetauscht werden.
Das Backend und die Datenbank blieben unverändert.
Um das Frontend mit dem neuen Framework (\textbf{Vue}) auszustatten, muss zunächst der Inhalt des bisherigen Ordners, der das Frontend beinhaltet, gelöscht werden.
Daraufhin konnte über das Werkzeug \textbf{Vite} ein \textbf{Vue}-Projekt erstellt werden, dass auch direkt \textbf{TypeScript} unterstützt.
Dies hilft beim Entwickeln schon frühzeitig Probleme zu entdecken und zu lösen.
Im folgenden Code-Snippet ist zu sehen, wie das Projekt mit \textbf{Vite} erstellt wurde.

\begin{lstlisting}[language={bash}, caption={Initialisierung des Vue Projektes mit Vite \cite{vitejs-getting-started}}]
npm create vite@latest
\end{lstlisting}

Nachdem das Projekt erstellt wurde, konnte der Inhalt des Projekts in den alten und leeren Ordner kopiert werden. Danach mussten lediglich noch Konfigurationen angepasst werden, ebenso wie Dockerfiles und Docker Compose. Die Konfigurationen betreffen das \textbf{TypeScript}- und \textbf{Vue}-Projekt, während die Dockerfiles und Docker Compose für die Containerisierung der Webseite zuständig sind. Die entsprechenden Konfigurationen und Dockerfiles sind im folgenden Code Snippet zu sehen.

\begin{lstlisting}[language={bash}, caption={Dockerfile für das Vue Projekt}]
# Use the official Node.js image as the base image
FROM node:16

# Set the working directory inside the container
WORKDIR /usr/src/app

# Copy only the package.json and package-lock.json files to leverage Docker cache
COPY package.json ./
COPY package-lock.json ./

# Install dependencies
RUN npm install

# Copy the entire project files to the container
COPY ./ ./

# Expose the port that the Vue app will run on (change this if your app uses a different port)
EXPOSE 3000

# Build the Vue project
RUN npm run build

# Command to start the Vue app
CMD ["npm", "run", "start"]
\end{lstlisting}

In der Docker Compose-Datei wird der Container für das Vue-Projekt erstellt und konfiguriert. Hierbei muss dann noch explizit der Port angegeben werden, auf dem die Webseite laufen soll.

\begin{lstlisting}[language={bash}, caption={Docker Compose für das Vue Projekt}]
version: "3.8"

client:
stdin_open: true
environment:
    - WDS_SOCKET_PORT=3050
    - CHOKIDAR_USEPOLLING=true
    - WATCHPACK_POLLING=true
build:
    dockerfile: Dockerfile
    context: ./client
volumes:
    - /app/node_modules
    - ./client:/app
ports:
    - "3000:3000"
\end{lstlisting}

Das alles funktioniert reibungslos. Außerdem muss in der \texttt{vite.config.ts}-Datei noch der Port angepasst werden, auf dem die Webseite laufen soll. Dieser muss mit dem Port in der Docker-Compose-Datei übereinstimmen.

\begin{lstlisting}[language={JavaScript}, caption={Port Konfiguration für das Vue Projekt}]
export default defineConfig({
    ...
    server: {
    host: '0.0.0.0',
    port: 3000,
},
});
\end{lstlisting}

Nach diesem Schritt ist das Projekt erfolgreich migriert und kann nun mit dem neuen Framework weiterentwickelt werden. Es ist auch möglich, alles über die Docker Compose Datei zu starten und zu stoppen.

\section{Unterstützung von PWA für Mobile NutzerInnen}

Zu Beginn dieser Arbeit wurde in \hyperref[chapter:2]{Kapitel 2} erwähnt, dass die Webseite trotz ihrer webbasierten Natur als App bezeichnet wird.
Um die Nutzererfahrung zu optimieren und die Benutzerfreundlichkeit der Webseite zu erhöhen, wird die Integration von \acf{PWA} angestrebt.
Eine \acs{PWA} ist eine Technologie, die es ermöglicht, Webseiten ähnlich wie native Mobile Apps zu nutzen.
Dies bedeutet, dass die Webseite auch offline zugänglich ist und auf dem Startbildschirm eines Smartphones installiert werden kann.
Dadurch wird die Interaktion mit der Webseite komfortabler und die Nutzererfahrung insgesamt verbessert. \cite{ms-pwa}

Die Implementierung von \acs{PWA} gestaltet sich vergleichsweise unkompliziert und erfordert nur wenige Schritte. Zunächst wird ein Plugin zu Vite hinzugefügt, das sich um die \acs{PWA}-Funktionalität kümmert. Dies kann einfach über die Konsole durch die Installation des entsprechenden Plugins erfolgen.

\begin{lstlisting}[language={bash}, caption={Installation des PWA Plugins}]
npm i vite-plugin-pwa -D 
\end{lstlisting}

Danach müssen wir die Vite-Konfiguration anpassen, um das Plugin zu aktivieren und zu konfigurieren.
Dies umfasst das Hinzufügen eines Manifests, eines Service Workers, sowie verschiedener Grafiken für mobile Geräte.
Im folgenden Code-Snippet wird dargestellt, wie die Vite-Konfiguration angepasst wurde, um die Unterstützung für \acs{PWA} zu integrieren.

\begin{lstlisting}[language={JavaScript}, caption={Angepasste Vite Konfiguration für PWA}]
...
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
    plugins: [
        ...
        VitePWA({
            registerType: 'autoUpdate',
            devOptions: {
                enabled: true,
            },
            includeAssets: [
                'favicon.ico',
                'apple-touch-icon.png',
                'mask-icon.svg',
            ],
            manifest: {
                name: 'CO2Runter',
                short_name: 'CO2Runter',
                description:
                    'CO2 Runter Webseite hilft bei der Reduktion von CO2',
                theme_color: '#ffffff',
                icons: [
                    {
                        src: '/pwa-192x192.png',
                        sizes: '192x192',
                        type: 'image/png',
                    },
                    {
                        src: '/pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png',
                    },
                    {
                        src: '/pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png',
                        purpose: 'any maskable',
                    },
                ],
            },
        }),
    ],
    ...
});
\end{lstlisting}

Ebenfalls erfordert es die Anpassung der \texttt{index.html}-Datei, um die im Manifest definierten Grafiken zu laden.

\begin{lstlisting}[language={JavaScript}, caption={Anpassungen an der index.html Datei}]
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CO2 Runter</title>
    <meta name="description" content="CO2 Runter Webseite hilft bei der Reduktion von CO2">

    <link rel="icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
    <link rel="mask-icon" href="/mask-icon.svg" color="#FFFFFF">
    <meta name="theme-color" content="#ffffff">
</head>

<body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
</body>

</html>
\end{lstlisting}

Das Manifest ist eine \acf{JSON}-Datei, die im Hintergrund von Vite generiert wird und Informationen über die Webseite enthält, wie den Namen, die Beschreibung, das Icon und die Farbe. Der Service Worker ist ein Skript, das im Hintergrund ausgeführt wird und die Offline-Funktionalität der App ermöglicht. Nun ist die Webseite als \acs{PWA} konfiguriert und kann auf dem Homescreen des Smartphones installiert werden. Um dies zu erleichtern, kann eine Komponente erstellt werden, die den NutzerInnen dazu auffordert, die Webseite zu installieren. Diese könnte wie folgt aussehen:

\begin{lstlisting}[language={JavaScript}, caption={PWA Vue Komponente}]
<script setup lang="ts">
import { onBeforeMount, ref } from 'vue';

const deferredPrompt = ref<any>(null);

const beforeInstallPromptHandler = (e: Event) => {
    e.preventDefault();
    deferredPrompt.value = e;
};

const appInstalledHandler = () => {
    deferredPrompt.value = null;
};

onBeforeMount(() => {
    window.addEventListener('beforeinstallprompt', beforeInstallPromptHandler);
    window.addEventListener('appinstalled', appInstalledHandler);
});

const dismiss = () => {
    deferredPrompt.value = null;
};

const install = () => {
    if (deferredPrompt.value) {
        deferredPrompt.value.prompt();
    }
};
</script>

<template>
    <v-alert
        v-if="deferredPrompt"
        icon="mdi-download"
        color="info"
        title="Alert title"
        text="Lorem ipsum dolor sit amet consectetur adipisicing elit. Commodi, ratione debitis quis est labore voluptatibus! Eaque cupiditate minima, at placeat totam, magni doloremque veniam neque porro libero rerum unde voluptatem!"
    >
        <br />
        <v-btn @click="dismiss">Dismiss</v-btn>
        <v-btn @click="install">Install</v-btn>
    </v-alert>

    <v-banner
        v-if="deferredPrompt"
        lines="one"
        icon="mdi-download"
        color="info"
    >
        <template v-slot:text>
            Willst du diese Webseite installieren?
        </template>

        <template v-slot:actions>
            <v-btn @click="dismiss">Nein</v-btn>
            <v-btn @click="install">Ja, installieren</v-btn>
        </template>
    </v-banner>
</template>

\end{lstlisting}

Die Integration dieser Komponente in die \texttt{App.vue}-Datei ist unkompliziert und wird dem NutzerInnen angezeigt, wenn die Webseite als \acs{PWA} installiert werden kann. Dadurch wird die Nutzererfahrung verbessert und die Webseite kann auch offline genutzt werden, ähnlich wie eine native App. \cite{vite-plugin-pwa}

\section{Projekt aufräumen und Strukturierung}

Bisher wurden essentielle Veränderungen an dem Framework gemacht.
Bevor es weitergeht, muss das Projekt aufgeräumt und strukturiert werden.
Dies beinhaltet das Entfernen von ungenutzten Dateien und das Umbenennen von Dateien, um eine konsistente Namenskonvention zu gewährleisten.
Außerdem müssen die Ordnerstruktur und die Dateistruktur überarbeitet werden, um eine bessere Übersichtlichkeit und Wartbarkeit des Projekts zu gewährleisten.
Dies beinhaltet das Erstellen von Ordnern für Komponenten, Seiten, Services und anderen wichtigen Dateien.
In Abbildung \ref{fig:ordnerstruktur_neu} ist die neue Ordnerstruktur zu erkennen.
Der gesamte Code des Frontends befindet sich im Ordner \textit{client} auf der Root-Ebene.
Innerhalb dessen befinden sich weitere Ordner.
Der \textit{src}-Ordner ist hierbei der interessanteste und wichtigste Ordner des client-Ordners.
\textit{src} ist eine Abkürzung für \textit{source} und beinhaltet sämtlichen Code für das Frontend Framework Vue.js, also Definitionen von Komponenten, Logik innerhalb der Komponenten sowie Konstanten, den Router und vieles mehr.
In der folgenden Auflistung wird erklärt, was genau die einzelnen Unterordner beinhalten und welchen Part in der neuen UI sie dabei einnehmen.
\begin{itemize}
    \item \textbf{assets}: Der \textit{assets}-Ordner beinhaltet jene Dinge, die nicht durch Quellcode angegeben werden können. Dazu zählen unter anderem Bilder, wofür der \textit{assets}-Ordner im Falle der CO2-Runter-Webseite hauptsächlich genutzt wurde. Die Bilder werden hier an einem zentralen Ort gespeichert, damit diese innerhalb der Komponenten, die die Bilder beispielsweise implementieren, verwenden werden können uns nicht überall im Quellcode verteilt sind.
    \item \textbf{components}: Das Herzstück des Projektes ist der \textit{components}-Ordner. In diesem Ordner liegen die Komponenten, aus welchen die finale Webseite später zusammengebaut wird. Man kann sich den \textit{components}-Ordner wie eine Art Baukasten vorstellen, aus dem die verschiedenen Seiten der CO2-Runter-Webseite schlußendlich zusammengebaut werden. Wie bereits in Kapitel \ref{chapter:neuerstellung_co2rechner} erwähnt, sind Beispiele für Komponenten unter anderem die QuestionStepper- oder CurrentCO2-Kompoenente.
    \item \textbf{composables}: Im Kontext von Vue-Anwendungen ist ein Composable eine Funktion, um zustandsbehaftete Logik zu kapseln und wiederzuverwenden. Somit befinden sich im \textit{composables}-Ordner alle Hilfsfunktionen, die helfen solche Logik zu kapseln und damit wiederverwendbar zu machen. Ein Beispiel im Sinne der CO2-Runter-Webseite wäre das Composable, das den aktuellen CO2-Wert innerhalb des Rechners nach dem Auswählen einer Antwortmöglichkeit neu berechnet und an das Frontend schickt.
    \item \textbf{constangs}: Der \textit{constants}-Ordner ist der Ablageort für Konstanten, die innerhalb der Applikation immer wieder verwendet werden oder Quellcode, der mithilfe von Konstanten einfacher bzw. kompakter dargestellt werden konnte. So werden zum Beispiel die Literaturquellen des FAQs in Konstanten gespeichert.
    \item \textbf{layout}: Wie der Name bereits verrät, werden in diesem Ordner Layouts für die verschiedenen Seiten der Webseite definiert. Da im Kontext der CO2-Runter-Webseite nur ein Layout verwendet wird, ist dieser dementsprechend nur mit einer \textit{Default.vue}-Datei befüllt.
    \item \textbf{plugins}: Plugins sind in sich geschlossener Code, die in der Regel Funktionen auf Anwendungsebene zu Vue hinzufügen. In unserem Fall musste das Plugin \textit{Vuetify} hinzugefügt werden, da über diese Anwendung Komponenten durch bereits vorher definierten Code aufgebaut wurde. Aus diesem Grund, wurde diese Plugininstallationsdatei im \textit{plugins}-Ordner abgelegt.
    \item \textbf{router}: Der \textit{router}-Ordner beinhaltet die Logik für den sogenannten Router. Ein Router ist dafür zuständig, für die unterschiedlichen Webseiten und teilweise auch für einzelne Abschnitte von Webseiten, spezielle URLs zu definieren. So kann z.b. über die URL \"https://co2runter.karlsruhe.de/rechner\" auf den CO2-Rechner zugegriffen werden. Die Datei \textit{routes.ts} speichert hierbei jegliche Routen ab und liegt innerhalb des \textit{router}-Ordners.
    \item \textbf{store}: Ein Store ist ein zentraler Ort, an dem Daten gespeichert werden, die über alle Anwendungskomponenten hinweg verfügbar sind und sein müssen. Jegliche Daten dieser Form werden im \textit{stores}-Ordner untergebracht. Beispiele für einen Store innerhalb der Anwendung ist das Loggen und abspeichern des CO2-Werts.
    \item \textbf{types}: Wie der Name eventuell bereits verraten lässt, werden im Ordner \textit{types} Objekte, sogenannte Typen definiert. Die Typen sind hierbei als exportierbare Interfaces implementiert, die später vom Frontendcode für Logik oder andere Dinge wiederverwendet werden können. Ein Beispiel für einen solchen Typen ist eine Literaturquelle (\textit{LiteratureSource}), die jeweils immer aus fünf Strings besteht: einem Titel, einem Autor, einem Veröffentlicher, einem Veröffentlichungsjahr und einer URL zur Literaturquelle.
    \item \textbf{views}: Innerhalb des \textit{views}-Ordner sind alle erreichbaren Seiten definiert und zu finden. Eine View setzt sich dabei aus den verschiedenen Komponenten zusammen, und sind somit die auf der Webseite zu sehenden Seiten, die durch die verschiedenen URLs (=Routen) aufgerufen werden können.
\end{itemize}

Zuguterletzt sind noch drei abschließende Dateien im \textit{src}-Ordner: \textit{App.vue} ist die oberste Schicht der UI, auf welcher die ganze Views durch den Router implementiert werden.
\textit{main.ts} ist eine weitere Datei, die die Plugins, welche im \textit{plugins}-Ordner liegen, auf der Anwednungsebene registriert.
Abschließend implementiert \textit{vite-env.d.ts} die Vite-Umgebung.\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/06/ordnerstruktur_projekt.png}
    \caption{Neue Ordnerstruktur der CO2-Runter-Webseite}
    \label{fig:ordnerstruktur_neu}
\end{figure}

\section{Anpassung der questions.json}
\label{sec:anpassung-der-questions-json}
Nachdem nun die Ordnerstruktur des Projekts aufgeräumt und neu strukturiert wurde, wird nun die \textit{questions.json} angegangen.
Da die bisherige \textit{questions.json} sehr unübersichtlich und tief verschachtelt war, wurde diese neu aufgebaut und neu strukturiert.
Die alte Struktur der \textit{questions.json} wird in \hyperref[lst:questions-json-old]{Listing 6.9} vereinfacht dargstellt.
Dort ist zu beobachten, dass die \acs{JSON} die Kategorien bereits besitzt, wie sie später im CO2-Rechner angezeigt werden.
Jede Kategorie beinhaltet den Namen der Kategorie, sowie eine Liste von Fragen.
Innerhalb der Frageliste, werden die Fragen erneut über das Attribut \textit{name} in mögliche Unterkategorien unterteilt.
Anschließened erkennt man ab Zeile 8 und Zeile 16 der \hyperref[lst:questions-json-old]{alten questions.json}, das sich hier ein \textit{quick}- und ein \textit{detailed}- Objekt eröffnen.
Diese beinhalten jeweils die eigentlichen Fragen, die im CO2-Rechner verwendet werden.
Standardmäßig werden die Fragen und Antworten aus dem \textit{quick}-Objekt geladen.
Schaltet der Nutzer jedoch die Frage auf detailliert um, wie es beim alten CO2-Rechner beispielweise in \hyperref[fig:co2runterapp-rechner]{Abbildung 2.2} zu sehen ist, werden die Fragen aus dem \textit{detialed}-Objekt geladen. \newpage

\begin{lstlisting}[language=JavaScript, caption=Aufbau der alten questions.json, label={lst:questions-json-old}]
    {
        "baseline": number,
        "category":[
            {
                "name": string,
                "questions": [
                    "name": string,
                    "quick": {
                        "text": string,
                        "typ": string,
                        "replies": [],
                        "values": [],
                        "defaultValue": number,
                        "selectedValue": number
                    },
                    "detailed": {
                        "questions": {
                            "text": string,
                            "typ": string,
                            "replies": [],
                            "values": [],
                            "defualtValue": number,
                            "selectedValue": number
                        },
                    },
                ],
                "formula": string,
            },
            {
                ...
            },
            {
                ...
            },
            {
                ...
            }
        ]
    }
\end{lstlisting} \newpage
Da im neuen CO2-Rechner keine Möglichkeit mehr geboten wird, zwischen detaillierten und kurzen Fragen umzuschalten, enthält die alte, verschachtelte \acs{JSON} viele Dinge, die gar nicht mehr gebraucht werden.
Aus diesem Grund wurde die \textit{questions.json} neu aufgebaut und strukturiert.
\hyperref[lst:questions-json-new]{Listing 6.10} zeigt den neuen Grundaufbau der \textit{questions.json}, die im neuen CO2-Rechner zukünftig verwendet wird.
\begin{lstlisting}[language=JavaScript, caption={Aufbau der neuen question.json}, label={lst:questions-json-new}]
    {
        "baseline": number,
        "category": [
            {
                "name": string,
                "questions": [
                    {
                        "text": string,
                        "replies": [
                            {
                                "text": string,
                                "value": number
                            },
                            {
                                ...
                            },
                        ],
                        "selected": {
                            "text": string,
                            "value" number
                        }
                    },
                ],
                "formula": string
            },
            {
                ...
            },
            {
                ...
            },
            {
                ...
            }
        ],
        "endFormula": string
    }
\end{lstlisting}
Die neue \acs{JSON} zeichnet sich dadurch aus, dass die Antworten einer Frage in Objekten aus einem \textit{text}- und einem \textit{value}-Objekt gespeichert sind.
Dadurch kann bei der Berechnung des CO2-Werts der Wert einer Antwortmöglichkeit, die im Frontend ausgewählt wurde, leichert gefunden werden und man muss muss sich nicht ewig durch die Datenstruktur der \acs{JSON} quälen.
Zusätzlich wurde wie bereits vorher erwähnt, die Fragenunterteilung in \textit{quick} und \textit{detailed} entfernt, so dass man insgesamt eine verständlichere Datenstruktur hat.
Somit wurde die Anforderung aus dem Kapitel 5.1.3 - \hyperref[sec:questions-json-anpassen]{[R14] Question.json anpassen} erledigt.

\section{Erstellung der neuen Landing Page}

Die Landing Page ist die erste Seite, die der NutzerInnen sieht, wenn er die Webseite besucht.
Sie ist somit das Aushängeschild der Webseite und sollte den NutzerInnen dazu animieren, die Webseite zu nutzen.
Die Landing Page sollte also ansprechend und informativ sein, um den NutzerInnen zu überzeugen, die Webseite zu nutzen als auch die zuvor definierte Anforderung \textbf{[R04]} erfüllen.
Die neue Landing Page wird mit \textbf{Vuetify} erstellt, einem Material Design Framework für Vue.js.
Vuetify bietet viele vorgefertigte Komponenten, die es ermöglichen, schnell und einfach ansprechende Webseiten zu erstellen.
Die Landing Page könnte wie folgt aussehen:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/06/HomePage-Design.jpeg}
    \caption{Die neu erstellte CO2-Runter Landing Page}
    \label{fig:new-co2runter-homepage-design}
\end{figure}

Das Design, welches in der \hyperref[fig:new-co2runter-homepage-design]{vorheriger Abbildung} zu sehen war, wurde anhand der Evaluierung der Umfrage und der erstellten Personas erstellt.
Dafür wurde das Tool Figma genutzt und auch direkt mit Vuetify Komponenten gearbeitet, wodurch die Entwicklungsarbeitszeit immens verkürzt wurde.
Das ist deshalb der Fall, da das Design und die Komponenten im späteren Implementierungsverlauf 1:1 übernommen werden konnten.

Die neue Homepage kann man in drei Sektionen unterteilen.
Einmal die Navigationsleiste, den Kontent der Landing Page und den Footer mit desen relevanten Informationen.
Zu beachten ist hierbei das die Navigationsleiste, als auch der Footer, auf allen Seiten identisch sein sollen.
Einzig der Kontent einer Seite ist dynamisch und soll deshalb veränderbar sein.
Daher werden die drei Sektionen im folgenden nacheinander durchgearbeitet.
Zuvor aber werden wichtige Änderungen vorgenommen.

\subsection{Änderungen}

Eine wichtige Änderung ist die Anpassung des Farbschemas, um die Webseite ansprechender zu gestalten. Dafür wird das Farbschema von Vuetify angepasst, um eine konsistente Farbgebung zu gewährleisten. Hierfür erstellen wir lediglich nach der Vuetify dokumentation ein neues Farbschema und passen die Farben an. Dieses Farbschema wird dann in der Vuetify Konfiguration eingebunden. Das Farbschema sieht dann wie folgt aus: \cite{vuetiy-custom-color-theme}

\begin{lstlisting}[language={JavaScript}, caption={Vuetify Farbschema anpassung}]
export default createVuetify({
    theme: {
        themes: {
            dark: false,
            colors: {
                primary: '#D0ECDE',
                'primary-darken-1': '#01502D',
                ...
            },
            variables: {
                ...
            },
        },
    },
});
\end{lstlisting}

Nicht nur die Farben, sondern auch das Layout sollte angepasst werden.
Dafür wird ein Layout erstellt, welches auf allen Seiten gleich ist und nur der Kontent variabel ist.
Dieses Layout wird dann in jeder Seite durch die Vue Router Funktionalität eingebunden.
Das Einbinden sieht wie folgt aus:

\begin{lstlisting}[language={JavaScript}, caption={Einbindung des Layouts in der Vue Router Konfiguration}]
const routes = [
    {
        path: '/',
        component: () => import('@/layouts/default/Default.vue'),
        children: [
            {
                path: '',
                name: 'Home',
                component: () => import('@/views/HomeView.vue'),
            },
        ],
    },
    ... weitere Routen ...
];
\end{lstlisting}

Damit das Einbinden richtig funktioniert, muss in der \texttt{Default.vue} Datei mindestens ein \texttt{<router-view />} Tag existieren, damit die jeweilige Seite eingebunden und angezeigt wird.
Das angepasste Layout der CO2-Runter-Webseite beinhaltet, dass auf jeder erreichbaren Seite die Navigationsleiste, der Kontent und der Footer angezeigt wird.
Dieses Layout wird dann in der \texttt{App.vue} Datei wiederum über ein \texttt{<router-view />} Tag eingebunden und sieht wie folgt aus:

\begin{lstlisting}[language={JavaScript}, caption={Layout Definition}]
<template>
    <v-app>
        <TheNavigationHeader />
        <RouterView />
        <TheFooter />
    </v-app>
</template>
\end{lstlisting}

Nachdem diese Schritte befolgt wurden und jede Seite das Layout eingebunden hat, sowie das Farbschema zu jeder Webseite angepasst wurde, kann sich nun um die restliche Komponenten gekümmert werden.
Dabei handelt es sich um die Komponenten der Navigationsleiste, des Kontents und des Footers.

\subsection{Navigationsleiste}

Eine Navigationsleiste dient dem NutzerInnen einer Webseite dazu, den Überblick über den aktuell zu sehenden Bereich einer Webseite zu behalten und biete eine schnelle und einfache Navigation über die Webseite.
Im Fall der CO2-Runter-App gibt es die Startseite, den CO2-Rechner, das Dashboard, sowie eine FAQ- und Gruppensystemseite.
Diese sollen über die Navigationsleiste erreichbar sein.
Die folgende Abbildung zeigt, wie die Navigationsleiste implementiert wurde: \newpage

\begin{lstlisting}[language={JavaScript}, caption={Navigationsleiste für Web als auch Mobile}]
<template>
    <v-app-bar :elevation="0">
        <v-app-bar-nav-icon @click="isDrawerOpen = !isDrawerOpen" />

        <v-toolbar-title>
            <Co2RunterLogo />
        </v-toolbar-title>

        <div>
            <Navigationsleiste />
        </div>
    </v-app-bar>

    <v-navigation-drawer v-model="isDrawerOpen">
        ...
    </v-navigation-drawer>
    <PWAInstallationDialog />
</template>
\end{lstlisting}

\subsection{Footer}
Ein Footer ist das Gegenstück zur Navigationsleiste und ist immer ganz am Ende bzw. am unteren Bereich einer Webseite zu finden.
Auch der Footer dient dazu, Informationen darzustellen und besser über eine Webseite navigieren zu können.
Um den Footer zu erzeugen, gibt es drei Bereiche.
Einmal die Logos der Partner, dann die rechtlichen Informationen und die technischen Informationen und an Ende der Copyright.

\begin{lstlisting}[language={JavaScript}, caption={Footer Definition}]
<template>
    <div>
        <h1 class="text-primary-darken-1">Erstellt in Kollaboration</h1>
        <v-container class="my-16">
            <Logos />
        </v-container>
        <v-container class="my-16">
            <Datenschutz-Impressum />
        </v-container>
    </div>

    <v-footer>
        <div class="text-primary-darken-1">
            2023 - heute | CO2Runter. Alle Rechte vorbehalten.
        </div>
    </v-footer>
</template>
\end{lstlisting}

\subsection{Kontent}
Der Hauptpart der neuen Landing Page ist selbstverständlich der Kontent.
Hier ist es besonders wichtig, die NutzerInnen direkt anzusprechen und die Seite attraktiv und interessant wirken zu lassen.
Aus diesem Grund wurde sich für ein Design entschieden, dass die wichtigsten Aspekte der Webseite mit interessanten Einführungstexten in Reihen auf der Landing Page zu sehen sind.
Jede Reihe ist unterteilt in einen linken und in einen rechten Part, welche jeweils abwechselnd mit Text bzw. mit einem passenden Bild gefüllt sind.
Dabei wechselt sich die Position des Textes und des Bilds nach jeder Reihe ab, sodass man auch ohne Trennlinien das Layout gut erkennen kann und dem Auge der NutzerInnen nicht langweilig wird.
Der Textpart ist hierbei immer mit einer kleinen Überschrift, einem Einführungstext sowie einem Button gefüllt.
Die Überschriften der insgesamt drei Reihen sind dabei so gewählt, dass die NutzerInnen angesprochen werden oder zumindest ein gewisses Grundinteresse geweckt wird.
Im Einführungstext unter der Überschrift wird dieses Konzept aufgegriffen und weiter über das angesprochene Thema informiert.
Durch den Button am Ende des Einführungstexts gelangen die NutzerInnen direkt auf die angesprochene und verlinkte Webseite und können sich unter anderem ihren CO2-Wert berechnen lassen oder sich weiter über den Klimaschutz auf der FAQ-Seite informieren.
Das Bild ist hingegen so gewählt, dass es zur jeweiligen Überschrift bzw. Thema des Absatzes passt. \par
Grundsätzlich ist auch der Kontent in den Hauptfarben der CO2-Runter-Webseite gehalten.
Jedoch wurden die Überschriften und Texte innerhalb der Buttons etwas dunkler und auffälliger gestaltet, da diese ja vom Auge der NutzerInnen direkt registriert werden sollen.
Dadurch wird der optimale Fokus gelenkt.
In der folgenden Abbildung ist der Code zum Kontent zu sehen:
\newpage

\begin{lstlisting}[language={JavaScript}, caption={Home Page Kontent}]
<template>
    <v-container justify="center">
        <v-row class="d-flex flex-column-reverse flex-md-row my-16">
            <v-col cols="12" md="7" class="text-center text-md-start">
                <h1 class="text-primary-darken-1">657,000,000 Tonnen</h1>
                <p class="text-secondary my-8">
                    Text1
                </p>
                <v-btn
                    variant="tonal"
                    :rounded="true"
                    color="primary-darken-1"
                    append-icon="mdi-chevron-right"
                    size="large"
                >
                    Aktion 1
                </v-btn>
            </v-col>
            <v-col class="d-flex align-center justify-center" cols="12" md="5">
                <v-img
                    width="360px"
                    height="200px"
                    src="../assets/undraw_nature_m5ll.svg"
                />
            </v-col>
        </v-row>
        ... weitere Reihen ...
    </v-container>
</template>
\end{lstlisting}

\section{Neuerstellung des CO2-Rechners}
\label{chapter:neuerstellung_co2rechner}

% TODO: Anforderung [R11] umsetzen: Anzeige von weiteren Quellen/Infos im CO2 Rechner
% TODO: Anforderung [R09] umsetzen: Visualisierung und Vergleich des CO2-Fußabdrucks
% TODO: Anforderung [R07] umsetzen: Durchführung des CO2-Rechner-Workflows
% TODO: Anforderung [R06] umsetzen: Tipps und Tricks zur Reduktion des CO2-Fußabdrucks
% TODO: Anforderung [R03] umsetzen: Hochladen von CO2 Daten
% TODO: Anforderung [R02] umsetzen: Berechnung von CO2 Fußabdruck
% TODO: Anforderung [R01] umsetzen: Abrufen der Bestandsdaten von der Datenbank

Der CO2-Rechner ist ein wichtiges Feature der Webseite, da dem NutzerInnen dadurch ermöglicht wird, seinen CO2-Fußabdruck zu berechnen und Tipps zur Reduzierung zu erhalten.
Bei der Neuerstellung hat man sich an der bisherigen Implementierung orientiert und diese verbessert.

Der CO2-Rechner besteht aus mehreren Kategorien, die der NutzerInnen durchlaufen muss, um seinen CO2-Fußabdruck zu berechnen.
Die Kategorien lauten: Mobilität, Ernährung, Wohnen und Konsum.
Der NutzerInnen muss für jede Kategorie verschiedene Fragen beantworten, um seinen CO2-Fußabdruck zu berechnen.
Die Fragen sind so gestaltet, dass der NutzerInnen sie leicht beantworten kann.
Die Fragen könnten wie folgt aussehen:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/06/Question_New_Design.png}
    \caption{Design einer Frage des neuen CO2-Rechners}
    \label{fig:new-co2runter-question-design}
\end{figure}

Besonders viel hat sich nicht am Design einer Frage innerhalb des Rechners geändert.
Es wurden jedoch mehr Fragen in den Rechner eingebaut, die im alten Design als "detailliert" beschrieben wurden.
Zusätzlich wurde, wie bereits im Abschnitt %hier einfügen
, der Wert hinter den Anwortmöglichkeiten angepasst sowie die gesamte Struktur des generierten \acs{JSON}.

Die größte Veränderung erlebt der neue CO2-Rechner in Sachen Allgemeindesign und Nutzerfreundlichkeit.
Wie in Abbildung \ref{fig:new-co2runter-calculator-design} zu sehen ist, wurde hier besonders darauf geachtet, dem NutzerInnen eine ansprechende Webseite zu präsentieren, die nicht nur als langweiliger und stumpfer Fragebogen durchgeht.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/06/Calculator-New-Design.jpeg}
    \caption{Design des neuen CO2-Rechners}
    \label{fig:new-co2runter-calculator-design}
\end{figure}

Der berechnete CO2-Wert aus den gewählten Antwortmöglichkeiten befindet sich nun direkt am Start der Webseite.
Um den berechneten Fußabdruck noch deutlicher in den Vordergrund zu setzen, wurde diesem die Primärfarbe verpasst, so dass er in einem dunkelgrün erscheint.

Eine weitere grundlegende Veränderung des neuen CO2-Rechners findet man unmittelbar unterhalb der Kategorienauflistung.
Bevor der NutzerInnen auf den eigentlichen Rechner stößt, wurde für jede Kategorie ein kleiner Einführungsabschnitt geschrieben und ein dazu passendes Bild hinzugefügt.
Diese Neuerung soll dafür sorgen, dass sich der NutzerInnen nicht direkt in den Rechner stürzt, sondern über das aktuelle Thema aufgeklärt und informiert wird.
Außerdem bringt der Abschnitt mit dem Bild einen positiven Aspekt im Bereich der Nutzerfreundlichkeit.

Für die Implementierung des neuen CO2-Rechner wurde eine neue Komponente namens "CalculatorView.vue" erstellt.
Diese bildet die Hauptansicht des Rechners und implementiert weitere, kleinere Komponenten, so genannte \textit{Components} und ist in der folgenden Abbildung zu sehen.

\begin{lstlisting}[language={JavaScript}, caption={Aufbau der CalculatorView.vue Komponente}]
<template>
    <v-container>
        <v-row
        class= ...
        >
            <v-col ...>
                <CurrentCO2 />
            </v-col>
            <v-col ... >
                <v-img
                width="360px"
                height="200px"
                src="../assets/undraw_nature_m5ll.svg"
                />
            </v-col>
        </v-row>

        <v-row ... >
            <v-col>
                <QuestionStepper />
            </v-col>
        </v-row>
    </v-container>
</template>
\end{lstlisting}

Wie bereits eingangs erwähnt, implementiert die CalculatorView-Komponente weitere Components.
In der Ordnerstruktur des Projekts findet man deshalb innerhalb des Components-Ordner einen Ordner mit dem Namen \textit{Calculator}.
In diesem Ordner befinden sich alle weiteren Komponenten, die für die Darstellung des CO2-Rechners benötigt werden.
So auch die Komponenten \textit{QuestionStepper} und \textit{CurrentCO2}, die durch die entsprechenden ".vue" Dateiendungen erzeugt werden und bereits in der vorherigen Abbildung erschienen sind.

CurrentCO2 ist dafür zuständig, aus den gegebenen Antworten des Nutzers den Wert des CO2-Fußabdrucks zu berechnen und diesen darzustellen.
Diese importiert den \textit{totalCo2Emission Store}, der dafür zuständig ist, die Werte der gewählten Antworten aus einer \acs{JSON} zu nehmen und auf den Gesamtwert zu addieren.
Anschließend wird der Gesamtwert in einer Card dargestellt.
Der Code für die CurrentCO2-Komponente sieht dabei folgendermaßen aus:

% TODO: readd Code-Snippet caused compilation problems
\begin{lstlisting}[language={html}, caption={CurrentCO2.vue}]
<template>
    <v-card class="text-primary" elevation="0">
        <v-card-text class="text-secondary">
            Und Setzt sich wie folgt zusammen:
        </v-card-text>
    </v-card>
</template>

<script lang="ts" setup>
import { useTotalCo2EmissionStore } from '@/store/totalCo2Emission';

const totalCo2EmissionStore = useTotalCo2EmissionStore();
</script>
\end{lstlisting}

Der QuestionStepper ist für die Darstellung des eigentlichen Fragebogens zuständig.
Der Fragebogen wird über den \textit{v-stepper} implementiert.
Dieser wird von Vuetify geliefert und ist in zwei Teile aufgeteilt: v-stepper-header und v-stepper-window.
Der \textit{v-stepper-header} ist für die Kategorienauflistung zuständig und begleitet den NutzerInnen durch den Fragebogen.
Durch den \textit{v-stepper-header} wird genau angezeigt, in welcher Kategorie des Fragebogens man sich gerade befindet und wie viele Kategorien es noch zu erledigen gibt.
Auf der anderen Seite ist das \textit{v-stepper-window} für die Auflistung der Fragen und somit für den Fragebogen zuständig.
Über so genannte \textit{v-stepper-window-items} werden die einzelnen Fragen dargestellt.
Für das Laden der Fragen und Antworten ist eine weitere Komponente zuständige, die in QuestionStepper.vue importiert wird: \textit{QuestionBlock}

\textit{QuestionBlock} ist dafür zuständig, die Fragen und Antworten aus der \textit{questions.json} zu laden und diese so darzustellen, dass QuestionStepper diese nur noch im richtigen Format einfügen muss.
Nachfolgend ist der Code für QuestionBlock.vue und QuestionStepper.vue aufgelistet:

\begin{lstlisting}[language={html}, caption={QuestionStepper.vue}]
<template>
    <v-stepper>
        <v-stepper-header>
        <v-stepper-item title="Mobilitaet" value="1"></v-stepper-item>

        <v-divider></v-divider>

        <v-stepper-item title="Ernaehrung" value="2"></v-stepper-item>

        <v-divider></v-divider>

        <v-stepper-item title="Wohnen" value="3"></v-stepper-item>

        <v-divider></v-divider>

        <v-stepper-item title="Konsum" value="4"></v-stepper-item>
        </v-stepper-header>

        <v-stepper-window>
            <v-stepper-window-item>

                .
                .
                .

                <v-row class="my-16">
                <v-col>
                <QuestionsBlock
                v-if="data"
                :category-index="QuestionsIndices.MOBILITY"
                :questions="
                data.category[QuestionsIndices.MOBILITY]
                "
                />
                </v-col>
                </v-row>

                .
                .
                .

            </v-stepper-window-item>
        </v-stepper-window>
    </v-stepper>
</template>
\end{lstlisting}

\begin{lstlisting}[language={html}, caption={QuestionBlock.vue}]
<template>
    <div
    v-for="(item, index) in questions.questions"
    :key="index"
    class="my-16"
    >
        <h3 class="text-center">{{ item.text }}</h3>
        <v-select
        v-model="item.selected.text"
        :items="item.replies.map((replies) => replies.text)"
        :return-object="true"
        class="mt-16"
        placeholder="Waehlen Sie eine Option"
        variant="outlined"
        @update:modelValue="UpdateEmissions(index)"
        ></v-select>
    </div>
</template>

<script lang="ts" setup>
import { Category, Replies } from '@/types/Questionnaire';
import useQuestions from '@/composables/useQuestions';
import { useTotalCo2EmissionStore } from '@/store/totalCo2Emission';

const props = defineProps<{
categoryIndex: number;
questions: Category;
}>();

const { updateSelectedValue, calculateTotalCo2Emission } = useQuestions();
const totalCo2EmissionStore = useTotalCo2EmissionStore();

const UpdateEmissions = (questionIndex: number) => {
const array = props.questions.questions[questionIndex].replies;
const textValue = props.questions.questions[questionIndex].selected.text;

const object = findObjectInArray(array, textValue);
updateSelectedValue(props.categoryIndex, questionIndex, object!);

totalCo2EmissionStore.calculateTotalCo2Emission(
calculateTotalCo2Emission()
);
};

function findObjectInArray(
array: Replies[],
textValue: string
): Replies | undefined {
return array.find((item) => item.text === textValue);
}
</script>
\end{lstlisting}

\section{Übernahme und Anpassung des Dashboards}

Das Dashboard spielt eine entscheidende Rolle auf der Webseite, indem es dem NutzerInnen ermöglicht, CO2-Emissionen zu verfolgen, zu analysieren und zu reduzieren. Es präsentiert dem NutzerInnen eine Vielzahl von Informationen über die Stadtteile von Karlsruhe. Insbesondere bietet das Dashboard eine interaktive Karte, die die Stadtteile von Karlsruhe und den durchschnittlichen CO2-Verbrauch gemäß den Angaben der NutzerInnen, die ihren Stadtteilen zugeordnet sind, darstellt. Um die \textbf{Anforderung [R05]} zu erfüllen, wird das Dashboard für die neue Webseite neu entwickelt und an das Framework sowie an die Benutzeroberfläche angepasst. Da dieses Feature bereits in der vorherigen Webseite implementiert war, kann darauf aufgebaut werden, um die \textbf{Anforderung [R05]} zu erfüllen. Das Dashboard wird in mehrere Komponenten unterteilt, die jeweils für einen bestimmten Teil des Dashboards verantwortlich sind.

Die Herausforderung besteht darin, die Funktionsweise des React-Codes in den neuen Vue-Code zu überführen und sicherzustellen, dass alles einwandfrei funktioniert. Die Bibliothek ECharts, die für die Grafiken genutzt wurde, kann auch problemlos in Vue verwendet werden, wodurch die gleichen Grafikoptionen wie zuvor verfügbar sind. Es müssen lediglich die Daten aus der Datenbank abgerufen und entsprechend angepasst werden, um die \textbf{Anforderung [R01]} zu erfüllen.
Anschließend müssen verschiedene Anpassungen vorgenommen werden, um sicherzustellen, dass alle Funktionalitäten problemlos funktionieren.
Die Umsetzung ist weniger kompliziert, als es zunächst erscheinen mag, erfordert jedoch Zeit, um die Integration in das neue Framework zu vollenden und den bestehenden React-Code zu verstehen.

\subsection{React Echarts alternative für Vue.js}

Der erste Schritt vor der eigentlichen Implementierung besteht darin, eine alternative Bibliothek zu finden, die ähnliche Grafiken wie ECharts bzw. React-Echarts erstellen kann, die in der alten Webseite genutzt wurden. Da ECharts so populär ist, gab es glücklicherweise auch eine Vue-ECharts Variante, was die Arbeit erleichterte, da die essentiellen Konfigurationen für die dargestellten Grafiken gleich blieben. Jetzt muss lediglich der Installationsprozess der Bibliothek durchgeführt werden, indem man die Bibliothek installiert und in die Vue-Komponenten einbindet.

\begin{lstlisting}[language={bash}, caption={Installation von Vue-ECharts}]
npm i echarts vue-echarts
\end{lstlisting}

Danach kann die Bibliothek in den Vue-Komponenten eingebunden werden und die Grafiken erstellt werden. \cite{vue-echarts}

\subsection{Integration von Echtzeitdaten}

Wie bereits bei der Implementierung des neuen CO2-Rechners sind Echtzeitdaten aus der Datenbank relevant. Dafür muss sich wie zuvor am bisherigen Code orientiert und die Datenbankabfragen angepasst werden. Zum Beispiel für die Fußabdrücke der NutzerInnen könnte dies wie folgt aussehen:

\begin{lstlisting}[language={JavaScript}, caption={Laden der Fußabdrücke der NutzerInnen}]
const fetchFootprints = async () => {
    const response = await fetch('/api/dashboard/footprints');
    const data: FootprintResponse = await response.json();
    return data;
};
\end{lstlisting}

Hier wird eine Funktion erstellt, die die Fußabdrücke der NutzerInnen aus der Datenbank abruft. Die Funktion kann dann in einer \textbf{onMounted} Funktion aufgerufen werden, damit die Daten beim Laden der Komponente angezeigt werden.

\begin{lstlisting}[language={JavaScript}, caption={Bei laden der Komponente die Fußabdrücke der NutzerInnen speichern}]
onMounted(async () => {
    footprintsData.value = await fetchFootprints();
});
\end{lstlisting}

\subsection{Erstellung der Karte mit Vue-ECharts}

Um die Karte zu erstellen, wird wie zuvor erklärt die Vue-ECharts Bibliothek verwendet, die es ermöglicht, interaktive Karten zu erstellen. Die Karte soll die Stadtteile von Karlsruhe und den durchschnittlichen CO2-Verbrauch gemäß den Angaben der NutzerInnen, die ihren Stadtteilen zugeordnet sind, anzeigen. Die Karte wird in einer Vue-Komponente erstellt und die Daten aus der Datenbank abgerufen und entsprechend angepasst, um die Karte zu erstellen. Die Karte könnte wie folgt aussehen:

\begin{lstlisting}[language={html}, caption={Vue-ECharts Diagramm Beispiel}]
<v-chart
    :option="chartOptions"
    style="height: 600px; width: 100%"
/>
\end{lstlisting}

Es ist relativ einfach, eine Karte mit Vue-ECharts zu erstellen, aber das Wichtigste ist, dass die Daten in das Diagramm gegeben werden und dass angegeben wird, wie das Diagramm aussehen soll (ob Karte, Balkendiagramm oder viele andere Möglichkeiten). Wichtig ist vor dem Eingehen auf die \textbf{chartOptions}, dass das Diagramm eine Höhe und Breite erhält, um korrekt angezeigt zu werden.

Bei den \textbf{chartOptions} handelt es sich um ein Objekt welches die Daten für die Grafik enthält. Hierbei wird die Karte erstellt und die Daten aus der Datenbank abgerufen und entsprechend angepasst, um die Karte zu erstellen. Dabei wird zunächst die \textbf{onMounted} Funktion erweiter. Sie soll nicht nur die Daten aus der Datenbank laden sondern auch direkt die konkreten Kartendaten erstellen. Danach sieht die Funktion wie folgt aus:

\begin{lstlisting}[language={JavaScript}, caption={Laden der Fußabdrücke und erstellen der Diagramm Daten und Konfiguration}]
onMounted(async () => {
    footprintsData.value = await fetchFootprints();
    chartOptions.value = getData();
});
\end{lstlisting}

Die \textbf{getData} Funktion ist dafür zuständig die Daten aus der Datenbank in ein Format zu bringen welches von der Vue-ECharts Bibliothek verstanden wird. Hierbei wird die Karte erstellt und die Daten aus der Datenbank abgerufen und entsprechend angepasst, um die Karte zu erstellen. Dabei konnten wir die bisherigen Konfigurationen von React-ECharts übernehmen und mussten lediglich die Daten anpassen. Um einen einblick zu erhalten was die \textbf{getData} beinhaltet hier ein Beispiel:

\begin{lstlisting}[language={JavaScript}, caption={Beispiel Konfiguration für ECharts Diagramme}]
function getData() {
    return {
        title: {
            text: 'CO2 Emissionen in Karlsruhe pro Stadtteil',
        },
        ...
        series: loading.value // Die Daten
            ? [
                {
                    name: "Mobilitaet",
                    type: 'map',
                    map: 'Karlsruhe',
                    showLegendSymbol: false,
                    emphasis: {
                        label: {
                            show: true,
                        },
                    },
                    data: footprintsData.value!.mobility,
                }, // weitere Kategorien folgen
            ] : [],
    };
}
\end{lstlisting}

Dieses Vorgehen konnte dann bei allen Grafiken und Diagrammen durchgeführt werden, um das Dashboard erfolgreich in die neue Webseite zu integrieren. Im Folgenden ist ein Screenshot des Kartendiagramms in der neuen Webseite zu sehen:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/06/Dashboard-Design.jpeg}
    \caption{Kartendiagramm des Dashboards in der neuen Webseite}
    \label{fig:new-co2runter-dashboard-design}
\end{figure}

\section{Das neue Gruppensystem}

Eine essentielle Funktion der alten Webseite war die Funktion, sich in Gruppen zusammenzuschließen und gemeinsam den CO2-Fußabdruck der Gruppe zu messen und sich gegenseitig zu motivieren, diesen zu reduzieren. Um die \textbf{Anforderung [R06]} zu erfüllen, wurde das Gruppensystem in die neue Webseite integriert und verbessert. Das Gruppensystem besteht aus mehreren Komponenten, die jeweils für einen bestimmten Teil des Gruppensystems verantwortlich sind.

Es gibt zunächst eine Seite zum Gruppensystem wo NutzerInnen Informationen zum Gruppensystem erhalten und die Möglichkeit haben, einer Gruppe beizutreten oder eine Gruppe zu erstellen.
\hyperref[fig:gruppensystem-neues-design]{Abbildung 6.6} zeigt diese Seite.
Wie zu erkennen ist, kann man im ersten Absatz eine neue Gruppe erstellen.
Im letzten Absatz der Seite ist es möglich, über den Gruppencode einer neuen Gruppe beizutreten.
Die Gruppenerstelltung ist relativ einfach und besteht lediglich darin einen Gruppennamen einzugeben und dann wird dadurch ein Gruppencode generiert welcher von anderen NutzerInnen genutzt werden kann, um der Gruppe beizutreten. Dieser Gruppencode kann beim Gruppensystem Übersichtsseiten in ein Eingabefeld eingegeben werden, um der Gruppe beizutreten.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/06/gruppensystem-design.png}
    \caption{Design der neuen Gruppensystemseite}
    \label{fig:gruppensystem-neues-design}
\end{figure}

All dies funktioniert natürlich nur wenn der Nutzer eingelogt ist, aber dann kann der/die NutzerIn über dein Konto auf eine Gruppeninformationen Seite gelangen, wo alle Informationen zu Gruppen dargestellt werden.

Für die Implementierung besteht der schwere Teil lediglich herauszufinden welche Daten benötigt werden und welche \acs{API} Schnittstellen benötigt werden.

Im folgenden Screenshot ist einmal die Seite zu erkennen, auf die man weitergeleitet wird, wenn ein/e NutzerIn eine neue Gruppe selbst erstellen möchte.
Dort werden die NutzerInnen aufgefordert einen Name für ihre Gruppe einzugeben.
Sobald die Gruppe erfolgreich erstellt wurde, erscheint dem/der NutzerIn eine Bestätigung mit einem Dashboardlink, Joinlink und dem Gruppencode.
\hyperref[label]{Abbildung 6.7} zeigt die Ansicht, in der eine neue Gruppe erstellt werden kann.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/06/gruppe-erstellen-design.png}
    \caption{Ansicht um eine neue Gruppe zu erstellen}
    \label{fig:neue-gruppe-design}
\end{figure}

Die \hyperref[fig:gruppe-erfolgreich-erstellt]{nächste Abbildung} zeigt die Bestätigungsseite nachdem die Gruppe erfolgreich erstellt wurde.
Zu beobachten sind zusätzlich die bereits erwähnten Links zur Dashboardansicht der Gruppe und ein Link, um andere Leute in die Gruppe einzuladen.
Ebenfalls wird ein QR-Code erstellt, über welchen andere NutzerInnen der Gruppe beitreten können.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/06/gruppen-erstellung-bestätigung.png}
    \caption{Bestätigungsansicht nach der erfolgreichen Erstellung einer Gruppe}
    \label{fig:gruppe-erfolgreich-erstellt}
\end{figure}

\newpage

% TODO: soll ich da mehr auf die Implementierung eingehen?



\section{FAQ-Seite}

Und zu guter Letzt wurde noch eine FAQ-Seite der neuen CO2-Runter Webseite hinzugefügt. Der Hintergrund dafür bestand darin, dass es bisher keine Möglichkeit gab, NutzerInnen Informationen zu geben, die nicht direkt mit dem CO2-Rechner oder dem Dashboard zu tun haben. Dadurch will man die Anforderung \textbf{[R07]} erfüllen.

Die FAQ-Seite soll NutzerInnen die Möglichkeit geben, Antworten auf häufig gestellte Fragen zu finden und zusätzlich eine Literaturliste enthalten, die die NutzerInnen nutzen können, um sich weiter zu informieren.

% TODO: Diese Literaturen werden außderdem auch genutzt um beim CO2-Rechner Tips und Tricks anzuzeigen, die den Nutzern helfen können ihren CO2-Fußabdruck zu reduzieren.

Die Implementierung dieser Seite ist relativ einfach, da es sich um eine statische Seite handelt. Die Daten für die FAQ-Seite werden aus einer \acs{JSON}-Datei abgerufen und entsprechend angepasst, um die FAQ-Seite zu erstellen. Hierfür wurden viele Designaspekte übernommen, die bereits auf der Landing Page verwendet wurden. Das Einzige Neue ist die Literaturliste, die durch eine Tabelle realisiert wurde. Hierfür wird lediglich die \acs{JSON}-Datei abgerufen und die Daten in die Tabelle eingefügt. Dies geschieht wie folgt:

\begin{lstlisting}[language={JavaScript}, caption={Laden der Literaturliste}]
<v-data-table
    v-model:page="page"
    :headers="headers"
    :items="LiteratureSources"
    :search="search"
>...</v-data-table>
\end{lstlisting}

Die Literaturliste wird in einer Tabelle dargestellt, die es den NutzerInnen ermöglicht, die Literaturquellen zu durchsuchen und auf die Quellen zuzugreifen. Die Tabelle enthält eine Spalte für den Titel der Quelle, eine Spalte für den Autor, eine Spalte für das Erscheinungsjahr und eine Spalte für den Link zur Quelle. Die Tabelle ist durchsuchbar und paginiert, um die Benutzerfreundlichkeit zu verbessern.

Alle Literaturelemente befinden sich in der \textbf{LiteratureSources}-Variable, die in einer separaten TypeScript-Datei definiert wurde. Dabei handelt es sich um ein Array von Objekten, die die Literaturquellen repräsentieren.

\begin{lstlisting}[language={JavaScript}, caption={Literaturelemente}]
export default const literatureSources: LiteratureSource[] = [
    {
        title: 'Test Title of a Book',
        author: 'Test Name',
        publisher: 'Test Publisher',
        publicationYear: '2019',
        url: 'http://example.com/test-title-of-a-book',
    },
];
\end{lstlisting}

Das finale Design der FAQ-Seite sieht sehr modern und übersichtlich aus und lädt den NutzerInnen dazu ein, sich weiter zu informieren.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/06/FAQ-Design.jpeg}
    \caption{Design der FAQ-Seite der neuen Webseite}
    \label{fig:new-co2runter-faq-design}
\end{figure}

% Überleitung ins nächste Kapitel

Nachdem die neue Webseite erfolgreich implementiert wurde, wird im nächsten Kapitel noch einmal alles zusammengefasst und ein Fazit über die Arbeit und die Ergebnisse gezogen.
