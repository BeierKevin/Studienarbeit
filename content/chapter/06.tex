%!TEX root = ../../main.tex

\chapter{Implementierung und Verbesserung der Webseite}
\label{chapter:6}

% TODO: die vlt einarbeiten oder sind die sachen schon drin ?
% > Dann die neuen Features einbauen (Probleme wurden ja gefixed) (Darauf aufbauen dann die UI darauf aufbauen)
% > evlt. weitere Features einbauen (Weitere Userzentrierte Features ausbauen)

In den vorherigen Kapiteln wurde die Webseite analysiert und die Nutzerumfrage wurde durchgeführt und ausgewertet. Diese Erkenntnisse sollen nun genutzt werden, um eine bessere Version der Webseite zu entwickeln. Bevor das jedoch geschehen kann, muss die bisherige Codebasis auf ein anderes Frontend-Framework migriert werden, da die Zufriedenheit mit dem bisherigen Framework nicht sehr hoch war. Nach der Migration werden dennoch die Ergebnisse der Nutzerumfrage genutzt, um die Webseite zu verbessern. Dabei wird auf die Ergebnisse der Nutzerumfrage eingegangen, und die Webseite wird so angepasst, dass die Nutzererfahrung verbessert wird. Außerdem werden neue Features und Funktionen hinzugefügt, die die Nutzererfahrung verbessern und die Nutzer dazu anregen sollen, die Webseite zu nutzen.

\section{Frameworkwechsel und Verbesserungen}

\subsection{Motivation für den Frameworkwechsel}

Die Webseite wurde bisher unter Verwendung des Frontend-Frameworks \textbf{React.js} entwickelt, das aufgrund seiner Beliebtheit bei vielen Entwicklern weit verbreitet ist. Dennoch wurde die Entscheidung getroffen, das Framework zu wechseln, bedingt durch verschiedene Herausforderungen und auch aufgrund von Kompetenzüberlegungen der Entwickler. Durch den Übergang zu einem anderen Framework soll die Webentwicklung vereinfacht und die Nutzererfahrung verbessert werden. Insbesondere sollen bekannte Probleme wie fehlerhaftes State Management vermieden werden.

Wie bereits im \hyperref[chapter:3-frontend-frameworks]{Grundlagenkapitel} erläutert, wird als neue Framework \textbf{Vue} eingeführt, dass ebenfalls weit verbreitet ist und von vielen Entwicklern genutzt wird.

\subsection{Umsetzung des Frameworkwechsels}

Die Umsetzung ist dabei zunächst nicht zu kompliziert, da das gesamte Projekt in verschiedene Teile unterteilt war, wie das Frontend der Webseite, das Backend und die Datenbank. Somit musste lediglich der Ordner, der das Frontend beinhaltet, ausgetauscht werden. Das Backend und die Datenbank blieben unverändert. Um das Frontend dann mit dem neuen Framework (\textbf{Vue}) auszustatten, muss zunächst der Inhalt des bisherigen Ordners, der das Frontend beinhaltet, gelöscht werden. Daraufhin konnte über das Werkzeug \textbf{Vite} ein \textbf{Vue}-Projekt erstellt werden, das auch direkt \textbf{TypeScript} unterstützt. Dies hilft beim Entwickeln, schon frühzeitig Probleme zu entdecken und zu lösen. Im folgenden Code-Snippet ist zu sehen, wie das Projekt mit \textbf{Vite} erstellt wurde.

\begin{lstlisting}[language={bash}, caption={Initialisierung des Vue Projektes mit Vite \cite{vitejs-getting-started}}]
npm create vite@latest
\end{lstlisting}

Nachdem das Projekt erstellt wurde, konnte der Inhalt des Projekts in den alten und leeren Ordner kopiert werden. Danach mussten lediglich noch Konfigurationen angepasst werden, ebenso wie Dockerfiles und Docker Compose. Die Konfigurationen betreffen das \textbf{TypeScript}- und \textbf{Vue}-Projekt, während die Dockerfiles und Docker Compose für die Containerisierung der Webseite zuständig sind. Die entsprechenden Konfigurationen und Dockerfiles sind im folgenden Code Snippet zu sehen.

\begin{lstlisting}[language={bash}, caption={Dockerfile für das Vue Projekt}]
# Use the official Node.js image as the base image
FROM node:16

# Set the working directory inside the container
WORKDIR /usr/src/app

# Copy only the package.json and package-lock.json files to leverage Docker cache
COPY package.json ./
COPY package-lock.json ./

# Install dependencies
RUN npm install

# Copy the entire project files to the container
COPY ./ ./

# Expose the port that the Vue app will run on (change this if your app uses a different port)
EXPOSE 3000

# Build the Vue project
RUN npm run build

# Command to start the Vue app
CMD ["npm", "run", "start"]
\end{lstlisting}

In der Docker Compose-Datei wird der Container für das Vue-Projekt erstellt und konfiguriert. Hierbei muss dann noch explizit der Port angegeben werden, auf dem die Webseite laufen soll.

\begin{lstlisting}[language={bash}, caption={Docker Compose für das Vue Projekt}]
version: "3.8"

client:
stdin_open: true
environment:
    - WDS_SOCKET_PORT=3050
    - CHOKIDAR_USEPOLLING=true
    - WATCHPACK_POLLING=true
build:
    dockerfile: Dockerfile
    context: ./client
volumes:
    - /app/node_modules
    - ./client:/app
ports:
    - "3000:3000"
\end{lstlisting}

Das alles funktioniert reibungslos. Außerdem muss in der \texttt{vite.config.ts}-Datei noch der Port angepasst werden, auf dem die Webseite laufen soll. Dieser muss mit dem Port in der Docker-Compose-Datei übereinstimmen.

\begin{lstlisting}[language={JavaScript}, caption={Port Konfiguration für das Vue Projekt}]
export default defineConfig({
    ...
    server: {
    host: '0.0.0.0',
    port: 3000,
},
});
\end{lstlisting}

Nach diesem Schritt ist das Projekt erfolgreich migriert und kann nun mit dem neuen Framework weiterentwickelt werden. Es ist auch möglich, alles über die Docker Compose Datei zu starten und zu stoppen.

\section{Unterstützung von PWA}

Zu Beginn dieser Arbeit wurde im \hyperref[chapter:2]{Kapitel 2} erwähnt, dass die Webseite trotz ihrer Web-basierten Natur als "App" bezeichnet wird. Um die Nutzererfahrung zu optimieren und die Benutzerfreundlichkeit der Webseite zu erhöhen, wird die Integration von \acf{PWA} angestrebt. Eine \acs{PWA} ist eine Technologie, die es ermöglicht, Webseiten ähnlich wie native Mobile Apps zu nutzen. Dies bedeutet, dass die Webseite auch offline zugänglich ist und auf dem Startbildschirm eines Smartphones installiert werden kann. Dadurch wird die Interaktion mit der Webseite komfortabler und die Nutzererfahrung insgesamt verbessert. \cite{ms-pwa}

Die Implementierung von \acs{PWA} gestaltet sich vergleichsweise unkompliziert und erfordert nur wenige Schritte. Zunächst wird ein Plugin zu Vite hinzugefügt, das sich um die \acs{PWA}-Funktionalität kümmert. Dies kann einfach über die Konsole durch die Installation des entsprechenden Plugins erfolgen.

\begin{lstlisting}[language={bash}, caption={Installation des PWA Plugins}]
npm i vite-plugin-pwa -D 
\end{lstlisting}

Danach müssen wir die Vite-Konfiguration anpassen, um das Plugin zu aktivieren und zu konfigurieren. Dies umfasst das Hinzufügen eines Manifests, eines Service Workers sowie verschiedener Grafiken für mobile Geräte. Im folgenden Code-Snippet wird dargestellt, wie die Vite-Konfiguration angepasst wurde, um die Unterstützung für \acs{PWA} zu integrieren.

\begin{lstlisting}[language={JavaScript}, caption={Angepasste Vite Konfiguration für PWA}]
...
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
    plugins: [
        ...
        VitePWA({
            registerType: 'autoUpdate',
            devOptions: {
                enabled: true,
            },
            includeAssets: [
                'favicon.ico',
                'apple-touch-icon.png',
                'mask-icon.svg',
            ],
            manifest: {
                name: 'CO2Runter',
                short_name: 'CO2Runter',
                description:
                    'CO2 Runter Webseite hilft bei der Reduktion von CO2',
                theme_color: '#ffffff',
                icons: [
                    {
                        src: '/pwa-192x192.png',
                        sizes: '192x192',
                        type: 'image/png',
                    },
                    {
                        src: '/pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png',
                    },
                    {
                        src: '/pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png',
                        purpose: 'any maskable',
                    },
                ],
            },
        }),
    ],
    ...
});
\end{lstlisting}

Ebenfalls erfordert es die Anpassung der \texttt{index.html}-Datei, um die im Manifest definierten Grafiken zu laden.

\begin{lstlisting}[language={JavaScript}, caption={Anpassungen an der index.html Datei}]
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CO2 Runter</title>
    <meta name="description" content="CO2 Runter Webseite hilft bei der Reduktion von CO2">

    <link rel="icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
    <link rel="mask-icon" href="/mask-icon.svg" color="#FFFFFF">
    <meta name="theme-color" content="#ffffff">
</head>

<body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
</body>

</html>
\end{lstlisting}

Das Manifest ist eine JSON-Datei, die im Hintergrund von Vite generiert wird und Informationen über die Webseite enthält, wie den Namen, die Beschreibung, das Icon und die Farbe. Der Service Worker ist ein Skript, das im Hintergrund ausgeführt wird und die Offline-Funktionalität der App ermöglicht. Nun ist die Webseite als \acs{PWA} konfiguriert und kann auf dem Homescreen des Smartphones installiert werden. Um dies zu erleichtern, kann eine Komponente erstellt werden, die den Nutzer dazu auffordert, die Webseite zu installieren. Diese könnte wie folgt aussehen:

\begin{lstlisting}[language={JavaScript}, caption={PWA Vue Komponente}]
<script setup lang="ts">
import { onBeforeMount, ref } from 'vue';

const deferredPrompt = ref<any>(null);

const beforeInstallPromptHandler = (e: Event) => {
    e.preventDefault();
    deferredPrompt.value = e;
};

const appInstalledHandler = () => {
    deferredPrompt.value = null;
};

onBeforeMount(() => {
    window.addEventListener('beforeinstallprompt', beforeInstallPromptHandler);
    window.addEventListener('appinstalled', appInstalledHandler);
});

const dismiss = () => {
    deferredPrompt.value = null;
};

const install = () => {
    if (deferredPrompt.value) {
        deferredPrompt.value.prompt();
    }
};
</script>

<template>
    <v-alert
        v-if="deferredPrompt"
        icon="mdi-download"
        color="info"
        title="Alert title"
        text="Lorem ipsum dolor sit amet consectetur adipisicing elit. Commodi, ratione debitis quis est labore voluptatibus! Eaque cupiditate minima, at placeat totam, magni doloremque veniam neque porro libero rerum unde voluptatem!"
    >
        <br />
        <v-btn @click="dismiss">Dismiss</v-btn>
        <v-btn @click="install">Install</v-btn>
    </v-alert>

    <v-banner
        v-if="deferredPrompt"
        lines="one"
        icon="mdi-download"
        color="info"
    >
        <template v-slot:text>
            Willst du diese Webseite installieren?
        </template>

        <template v-slot:actions>
            <v-btn @click="dismiss">Nein</v-btn>
            <v-btn @click="install">Ja, installieren</v-btn>
        </template>
    </v-banner>
</template>

\end{lstlisting}

Die Integration dieser Komponente in die \texttt{App.vue}-Datei ist unkompliziert und wird dem Nutzer angezeigt, wenn die Webseite als \acs{PWA} installiert werden kann. Dadurch wird die Nutzererfahrung verbessert und die Webseite kann auch offline genutzt werden, ähnlich wie eine native App. \cite{vite-plugin-pwa}

\section{Projekt aufräumen und Verbesserungen}

\section{Implementierung von Verbesserungen }

\subsection{Umsetzung der Ergebnisse aus der Nutzerumfrage}

\subsection{Integration neuer Features und Funktionen}

\section{Erweiterung der Nutzererfahrung}

\subsection{Interaktive Landing Page und benutzerfreundliche UI-Gestaltung}

\subsection{Anreize zur Aktivität und Engagement der Nutzer}
